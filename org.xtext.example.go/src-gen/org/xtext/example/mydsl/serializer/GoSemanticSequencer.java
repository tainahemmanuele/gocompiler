/*
 * generated by Xtext 2.15.0-SNAPSHOT
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.go.Arguments;
import org.xtext.example.mydsl.go.Assignment;
import org.xtext.example.mydsl.go.ChannelType;
import org.xtext.example.mydsl.go.CommCase;
import org.xtext.example.mydsl.go.Compilation_initial;
import org.xtext.example.mydsl.go.CompositeLit;
import org.xtext.example.mydsl.go.ConstDecl;
import org.xtext.example.mydsl.go.Conversion;
import org.xtext.example.mydsl.go.ExprSwitchCase;
import org.xtext.example.mydsl.go.ExprSwitchStmt;
import org.xtext.example.mydsl.go.Expression2;
import org.xtext.example.mydsl.go.FieldDecl;
import org.xtext.example.mydsl.go.ForClause;
import org.xtext.example.mydsl.go.ForStmt;
import org.xtext.example.mydsl.go.FunctionDecl;
import org.xtext.example.mydsl.go.GoPackage;
import org.xtext.example.mydsl.go.IfStmt;
import org.xtext.example.mydsl.go.ImportDecl;
import org.xtext.example.mydsl.go.Index;
import org.xtext.example.mydsl.go.InterfaceType;
import org.xtext.example.mydsl.go.Key;
import org.xtext.example.mydsl.go.KeyedElement;
import org.xtext.example.mydsl.go.LabeledStmt;
import org.xtext.example.mydsl.go.Literal;
import org.xtext.example.mydsl.go.LiteralType;
import org.xtext.example.mydsl.go.LiteralValue;
import org.xtext.example.mydsl.go.MapType;
import org.xtext.example.mydsl.go.MethodDecl;
import org.xtext.example.mydsl.go.MethodSpec;
import org.xtext.example.mydsl.go.Model;
import org.xtext.example.mydsl.go.Operand;
import org.xtext.example.mydsl.go.ParameterDecl;
import org.xtext.example.mydsl.go.Parameters;
import org.xtext.example.mydsl.go.PointerType;
import org.xtext.example.mydsl.go.PrimaryExpr2;
import org.xtext.example.mydsl.go.RangeClause;
import org.xtext.example.mydsl.go.ReceiverType;
import org.xtext.example.mydsl.go.RecvStmt;
import org.xtext.example.mydsl.go.ReturnStmt;
import org.xtext.example.mydsl.go.SelectStmt;
import org.xtext.example.mydsl.go.SendStmt;
import org.xtext.example.mydsl.go.SimpleStmt;
import org.xtext.example.mydsl.go.Slice;
import org.xtext.example.mydsl.go.SliceType;
import org.xtext.example.mydsl.go.Statement;
import org.xtext.example.mydsl.go.StatementList;
import org.xtext.example.mydsl.go.StructType;
import org.xtext.example.mydsl.go.Type;
import org.xtext.example.mydsl.go.TypeDecl;
import org.xtext.example.mydsl.go.TypeList;
import org.xtext.example.mydsl.go.TypeSwitchCase;
import org.xtext.example.mydsl.go.TypeSwitchStmt;
import org.xtext.example.mydsl.go.VarDecl;
import org.xtext.example.mydsl.services.GoGrammarAccess;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case GoPackage.ASSIGNMENT:
				if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForClauseRule()) {
					sequence_Assignment_ForClause(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()
						|| rule == grammarAccess.getTypeSwitchStmtRule()) {
					sequence_Assignment_TypeSwitchStmt(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.CHANNEL_TYPE:
				if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getChannelTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_ChannelType(context, (ChannelType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ChannelType_ConstSpec(context, (ChannelType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_ChannelType_VarSpec(context, (ChannelType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.COMM_CASE:
				if (rule == grammarAccess.getCommCaseRule()) {
					sequence_CommCase(context, (CommCase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCommClauseRule()) {
					sequence_CommCase_CommClause(context, (CommCase) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.COMPILATION_INITIAL:
				sequence_Compilation_initial(context, (Compilation_initial) semanticObject); 
				return; 
			case GoPackage.COMPOSITE_LIT:
				sequence_CompositeLit(context, (CompositeLit) semanticObject); 
				return; 
			case GoPackage.CONST_DECL:
				sequence_ConstDecl(context, (ConstDecl) semanticObject); 
				return; 
			case GoPackage.CONVERSION:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ArrayType_ConstSpec_Conversion_Expression_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_ArrayType_Conversion_Expression_ExpressionList_PrimaryExpr_VarSpec(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getArrayTypeRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_ArrayType_Conversion_Expression_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConversionRule()) {
					sequence_Conversion(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementListRule()) {
					sequence_Conversion_ElementList_Expression_KeyedElement_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForClauseRule()) {
					sequence_Conversion_Expression_ExpressionList_ForClause_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getShortVarDeclRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()
						|| rule == grammarAccess.getExpressionListRule()) {
					sequence_Conversion_Expression_ExpressionList_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecvStmtRule()) {
					sequence_Conversion_Expression_ExpressionList_PrimaryExpr_RecvStmt(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()
						|| rule == grammarAccess.getTypeSwitchStmtRule()) {
					sequence_Conversion_Expression_ExpressionList_PrimaryExpr_TypeSwitchStmt(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_Conversion_Expression_KeyedElement_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArrayLengthRule()
						|| rule == grammarAccess.getDeferStmtRule()
						|| rule == grammarAccess.getExpressionStmtRule()
						|| rule == grammarAccess.getChannelRule()
						|| rule == grammarAccess.getIncDecStmtRule()
						|| rule == grammarAccess.getRecvExprRule()
						|| rule == grammarAccess.getConditionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getKeyRule()
						|| rule == grammarAccess.getElementRule()) {
					sequence_Conversion_Expression_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeSwitchGuardRule()
						|| rule == grammarAccess.getUnaryExprRule()
						|| rule == grammarAccess.getPrimaryExprRule()) {
					sequence_Conversion_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.EXPR_SWITCH_CASE:
				if (rule == grammarAccess.getExprCaseClauseRule()) {
					sequence_ExprCaseClause_ExprSwitchCase(context, (ExprSwitchCase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExprSwitchCaseRule()) {
					sequence_ExprSwitchCase(context, (ExprSwitchCase) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.EXPR_SWITCH_STMT:
				sequence_ExprSwitchStmt(context, (ExprSwitchStmt) semanticObject); 
				return; 
			case GoPackage.EXPRESSION2:
				sequence_Expression2(context, (Expression2) semanticObject); 
				return; 
			case GoPackage.FIELD_DECL:
				sequence_FieldDecl(context, (FieldDecl) semanticObject); 
				return; 
			case GoPackage.FOR_CLAUSE:
				sequence_ForClause(context, (ForClause) semanticObject); 
				return; 
			case GoPackage.FOR_STMT:
				sequence_ForStmt(context, (ForStmt) semanticObject); 
				return; 
			case GoPackage.FUNCTION_DECL:
				sequence_FunctionDecl(context, (FunctionDecl) semanticObject); 
				return; 
			case GoPackage.IF_STMT:
				sequence_IfStmt(context, (IfStmt) semanticObject); 
				return; 
			case GoPackage.IMPORT_DECL:
				sequence_ImportDecl(context, (ImportDecl) semanticObject); 
				return; 
			case GoPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case GoPackage.INTERFACE_TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_InterfaceType(context, (InterfaceType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getInterfaceTypeRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_InterfaceType(context, (InterfaceType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_InterfaceType_VarSpec(context, (InterfaceType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.KEY:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_Key_KeyedElement(context, (Key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyRule()) {
					sequence_Key(context, (Key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_Key_KeyedElement(context, (Key) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.KEYED_ELEMENT:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_KeyedElement(context, (KeyedElement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_KeyedElement(context, (KeyedElement) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.LABELED_STMT:
				sequence_LabeledStmt(context, (LabeledStmt) semanticObject); 
				return; 
			case GoPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case GoPackage.LITERAL_TYPE:
				sequence_LiteralType(context, (LiteralType) semanticObject); 
				return; 
			case GoPackage.LITERAL_VALUE:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_KeyedElement_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_KeyedElement_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralValueRule()
						|| rule == grammarAccess.getKeyRule()
						|| rule == grammarAccess.getElementRule()) {
					sequence_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.MAP_TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_MapType(context, (MapType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getMapTypeRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_MapType(context, (MapType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_MapType_VarSpec(context, (MapType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.METHOD_DECL:
				sequence_MethodDecl(context, (MethodDecl) semanticObject); 
				return; 
			case GoPackage.METHOD_SPEC:
				sequence_MethodSpec(context, (MethodSpec) semanticObject); 
				return; 
			case GoPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GoPackage.OPERAND:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ArrayType_ConstSpec_Expression_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_ArrayType_Expression_ExpressionList_Operand_PrimaryExpr_VarSpec(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getArrayTypeRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_ArrayType_Expression_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_Expression_KeyedElement_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForClauseRule()) {
					sequence_Expression_ExpressionList_ForClause_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getShortVarDeclRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()
						|| rule == grammarAccess.getExpressionListRule()) {
					sequence_Expression_ExpressionList_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecvStmtRule()) {
					sequence_Expression_ExpressionList_Operand_PrimaryExpr_RecvStmt(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()
						|| rule == grammarAccess.getTypeSwitchStmtRule()) {
					sequence_Expression_ExpressionList_Operand_PrimaryExpr_TypeSwitchStmt(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_Expression_KeyedElement_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArrayLengthRule()
						|| rule == grammarAccess.getDeferStmtRule()
						|| rule == grammarAccess.getExpressionStmtRule()
						|| rule == grammarAccess.getChannelRule()
						|| rule == grammarAccess.getIncDecStmtRule()
						|| rule == grammarAccess.getRecvExprRule()
						|| rule == grammarAccess.getConditionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getKeyRule()
						|| rule == grammarAccess.getElementRule()) {
					sequence_Expression_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()) {
					sequence_Operand(context, (Operand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeSwitchGuardRule()
						|| rule == grammarAccess.getUnaryExprRule()
						|| rule == grammarAccess.getPrimaryExprRule()) {
					sequence_Operand_PrimaryExpr(context, (Operand) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PARAMETER_DECL:
				if (rule == grammarAccess.getParameterDeclRule()) {
					sequence_ParameterDecl(context, (ParameterDecl) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterListRule()) {
					sequence_ParameterDecl_ParameterList(context, (ParameterDecl) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PARAMETERS:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_Parameters_Signature(context, (Parameters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_Parameters_Signature(context, (Parameters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReceiverRule()
						|| rule == grammarAccess.getParametersRule()) {
					sequence_Parameters(context, (Parameters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getFunctionTypeRule()
						|| rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getMethodSpecRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_Parameters_Signature(context, (Parameters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_Parameters_Signature_VarSpec(context, (Parameters) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.POINTER_TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_PointerType(context, (PointerType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getPointerTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_PointerType(context, (PointerType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_PointerType_VarSpec(context, (PointerType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PRIMARY_EXPR2:
				sequence_PrimaryExpr2(context, (PrimaryExpr2) semanticObject); 
				return; 
			case GoPackage.RANGE_CLAUSE:
				sequence_RangeClause(context, (RangeClause) semanticObject); 
				return; 
			case GoPackage.RECEIVER_TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ArrayType_ConstSpec_Expression_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_ArrayType_Expression_ExpressionList_PrimaryExpr_ReceiverType_VarSpec(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getArrayTypeRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_ArrayType_Expression_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_Expression_KeyedElement_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForClauseRule()) {
					sequence_Expression_ExpressionList_ForClause_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getShortVarDeclRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()
						|| rule == grammarAccess.getExpressionListRule()) {
					sequence_Expression_ExpressionList_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecvStmtRule()) {
					sequence_Expression_ExpressionList_PrimaryExpr_ReceiverType_RecvStmt(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()
						|| rule == grammarAccess.getTypeSwitchStmtRule()) {
					sequence_Expression_ExpressionList_PrimaryExpr_ReceiverType_TypeSwitchStmt(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_Expression_KeyedElement_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArrayLengthRule()
						|| rule == grammarAccess.getDeferStmtRule()
						|| rule == grammarAccess.getExpressionStmtRule()
						|| rule == grammarAccess.getChannelRule()
						|| rule == grammarAccess.getIncDecStmtRule()
						|| rule == grammarAccess.getRecvExprRule()
						|| rule == grammarAccess.getConditionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getKeyRule()
						|| rule == grammarAccess.getElementRule()) {
					sequence_Expression_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeSwitchGuardRule()
						|| rule == grammarAccess.getUnaryExprRule()
						|| rule == grammarAccess.getPrimaryExprRule()) {
					sequence_PrimaryExpr_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodExprRule()
						|| rule == grammarAccess.getReceiverTypeRule()) {
					sequence_ReceiverType(context, (ReceiverType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.RECV_STMT:
				sequence_RecvStmt(context, (RecvStmt) semanticObject); 
				return; 
			case GoPackage.RETURN_STMT:
				sequence_ReturnStmt(context, (ReturnStmt) semanticObject); 
				return; 
			case GoPackage.SELECT_STMT:
				sequence_SelectStmt(context, (SelectStmt) semanticObject); 
				return; 
			case GoPackage.SEND_STMT:
				if (rule == grammarAccess.getForClauseRule()) {
					sequence_ForClause_SendStmt(context, (SendStmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getSendStmtRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()) {
					sequence_SendStmt(context, (SendStmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()
						|| rule == grammarAccess.getTypeSwitchStmtRule()) {
					sequence_SendStmt_TypeSwitchStmt(context, (SendStmt) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.SIMPLE_STMT:
				if (rule == grammarAccess.getForClauseRule()) {
					sequence_ForClause_SimpleStmt(context, (SimpleStmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()) {
					sequence_SimpleStmt(context, (SimpleStmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()
						|| rule == grammarAccess.getTypeSwitchStmtRule()) {
					sequence_SimpleStmt_TypeSwitchStmt(context, (SimpleStmt) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.SLICE:
				sequence_Slice(context, (Slice) semanticObject); 
				return; 
			case GoPackage.SLICE_TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_SliceType(context, (SliceType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getSliceTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_SliceType(context, (SliceType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_SliceType_VarSpec(context, (SliceType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case GoPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case GoPackage.STRUCT_TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getStructTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_StructType_VarSpec(context, (StructType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.TYPE:
				if (rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getBaseTypeRule()
						|| rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeAssertionRule()) {
					sequence_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarSpecRule()) {
					sequence_Type_VarSpec(context, (Type) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.TYPE_DECL:
				sequence_TypeDecl(context, (TypeDecl) semanticObject); 
				return; 
			case GoPackage.TYPE_LIST:
				sequence_TypeList(context, (TypeList) semanticObject); 
				return; 
			case GoPackage.TYPE_SWITCH_CASE:
				if (rule == grammarAccess.getTypeCaseClauseRule()) {
					sequence_TypeCaseClause_TypeSwitchCase(context, (TypeSwitchCase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeSwitchCaseRule()) {
					sequence_TypeSwitchCase(context, (TypeSwitchCase) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.TYPE_SWITCH_STMT:
				sequence_TypeSwitchStmt(context, (TypeSwitchStmt) semanticObject); 
				return; 
			case GoPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     (expressionlist=ExpressionList | (type=Type expressionlist=ExpressionList?))?
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns Conversion
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         expression=Expression 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         elemtype=ElementType 
	 *         expressionlist=ExpressionList
	 *     )
	 */
	protected void sequence_ArrayType_ConstSpec_Conversion_Expression_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_1_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getArrayTypeAccess().getElemtypeElementTypeParserRuleCall_3_0(), semanticObject.getElemtype());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns Operand
	 *
	 * Constraint:
	 *     (
	 *         (literal=Literal | operandn=OperandName | expression=Expression) 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         elemtype=ElementType 
	 *         expressionlist=ExpressionList
	 *     )
	 */
	protected void sequence_ArrayType_ConstSpec_Expression_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 elemtype=ElementType expressionlist=ExpressionList)
	 */
	protected void sequence_ArrayType_ConstSpec_Expression_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_2_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getArrayTypeAccess().getElemtypeElementTypeParserRuleCall_3_0(), semanticObject.getElemtype());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns Conversion
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         expression=Expression 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         ((elemtype=ElementType expressionlist=ExpressionList?) | expression2+=Expression+)?
	 *     )
	 */
	protected void sequence_ArrayType_Conversion_Expression_ExpressionList_PrimaryExpr_VarSpec(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Conversion
	 *     TypeLit returns Conversion
	 *     ArrayType returns Conversion
	 *     ElementType returns Conversion
	 *     BaseType returns Conversion
	 *     Result returns Conversion
	 *     KeyType returns Conversion
	 *     TypeSpec returns Conversion
	 *     TypeDef returns Conversion
	 *     AliasDecl returns Conversion
	 *     TypeAssertion returns Conversion
	 *
	 * Constraint:
	 *     (type=Type expression=Expression pr=PrimaryExpr2 exp=Expression2 elemtype=ElementType)
	 */
	protected void sequence_ArrayType_Conversion_Expression_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_1_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getArrayTypeAccess().getElemtypeElementTypeParserRuleCall_3_0(), semanticObject.getElemtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns Operand
	 *
	 * Constraint:
	 *     (
	 *         (literal=Literal | operandn=OperandName | expression=Expression) 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         ((elemtype=ElementType expressionlist=ExpressionList?) | expression2+=Expression+)?
	 *     )
	 */
	protected void sequence_ArrayType_Expression_ExpressionList_Operand_PrimaryExpr_VarSpec(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 ((elemtype=ElementType expressionlist=ExpressionList?) | expression2+=Expression+)?)
	 */
	protected void sequence_ArrayType_Expression_ExpressionList_PrimaryExpr_ReceiverType_VarSpec(ISerializationContext context, ReceiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Operand
	 *     TypeLit returns Operand
	 *     ArrayType returns Operand
	 *     ElementType returns Operand
	 *     BaseType returns Operand
	 *     Result returns Operand
	 *     KeyType returns Operand
	 *     TypeSpec returns Operand
	 *     TypeDef returns Operand
	 *     AliasDecl returns Operand
	 *     TypeAssertion returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2 exp=Expression2 elemtype=ElementType)
	 */
	protected void sequence_ArrayType_Expression_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ReceiverType
	 *     TypeLit returns ReceiverType
	 *     ArrayType returns ReceiverType
	 *     ElementType returns ReceiverType
	 *     BaseType returns ReceiverType
	 *     Result returns ReceiverType
	 *     KeyType returns ReceiverType
	 *     TypeSpec returns ReceiverType
	 *     TypeDef returns ReceiverType
	 *     AliasDecl returns ReceiverType
	 *     TypeAssertion returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 elemtype=ElementType)
	 */
	protected void sequence_ArrayType_Expression_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_LENGTH__ELEMTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_2_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getArrayTypeAccess().getElemtypeElementTypeParserRuleCall_3_0(), semanticObject.getElemtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns Assignment
	 *     Assignment returns Assignment
	 *     InitStmt returns Assignment
	 *     PostStmt returns Assignment
	 *
	 * Constraint:
	 *     (expressionlist=ExpressionList expressionlist2=ExpressionList)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPRESSIONLIST));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPRESSIONLIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPRESSIONLIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionlistExpressionListParserRuleCall_0_0(), semanticObject.getExpressionlist());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionlist2ExpressionListParserRuleCall_2_0(), semanticObject.getExpressionlist2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns Assignment
	 *
	 * Constraint:
	 *     (expressionlist=ExpressionList expressionlist2=ExpressionList condition=Condition? poststmt=PostStmt)
	 */
	protected void sequence_Assignment_ForClause(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns Assignment
	 *     TypeSwitchStmt returns Assignment
	 *
	 * Constraint:
	 *     (expressionlist=ExpressionList expressionlist2=ExpressionList typesg=TypeSwitchGuard typecc+=TypeCaseClause*)
	 */
	protected void sequence_Assignment_TypeSwitchStmt(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ChannelType
	 *     TypeLit returns ChannelType
	 *     ElementType returns ChannelType
	 *     BaseType returns ChannelType
	 *     Result returns ChannelType
	 *     KeyType returns ChannelType
	 *     ChannelType returns ChannelType
	 *     TypeSpec returns ChannelType
	 *     TypeDef returns ChannelType
	 *     AliasDecl returns ChannelType
	 *     TypeAssertion returns ChannelType
	 *
	 * Constraint:
	 *     elemtype=ElementType
	 */
	protected void sequence_ChannelType(ISerializationContext context, ChannelType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CHANNEL_TYPE__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CHANNEL_TYPE__ELEMTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelTypeAccess().getElemtypeElementTypeParserRuleCall_1_0(), semanticObject.getElemtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns ChannelType
	 *
	 * Constraint:
	 *     (elemtype=ElementType expressionlist=ExpressionList)
	 */
	protected void sequence_ChannelType_ConstSpec(ISerializationContext context, ChannelType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CHANNEL_TYPE__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CHANNEL_TYPE__ELEMTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelTypeAccess().getElemtypeElementTypeParserRuleCall_1_0(), semanticObject.getElemtype());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns ChannelType
	 *
	 * Constraint:
	 *     (elemtype=ElementType expressionlist=ExpressionList?)
	 */
	protected void sequence_ChannelType_VarSpec(ISerializationContext context, ChannelType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommCase returns CommCase
	 *
	 * Constraint:
	 *     (sendstmt=SendStmt | recvstmt=RecvStmt)?
	 */
	protected void sequence_CommCase(ISerializationContext context, CommCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommClause returns CommCase
	 *
	 * Constraint:
	 *     ((sendstmt=SendStmt | recvstmt=RecvStmt)? statementlist2=StatementList)
	 */
	protected void sequence_CommCase_CommClause(ISerializationContext context, CommCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Compilation_initial returns Compilation_initial
	 *
	 * Constraint:
	 *     (initial=PackageClause importdecl+=ImportDecl* toplevel+=TopLevelDecl*)?
	 */
	protected void sequence_Compilation_initial(ISerializationContext context, Compilation_initial semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns CompositeLit
	 *     CompositeLit returns CompositeLit
	 *
	 * Constraint:
	 *     (literalt=LiteralType literalv=LiteralValue)
	 */
	protected void sequence_CompositeLit(ISerializationContext context, CompositeLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERALT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERALT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERALV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERALV));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteraltLiteralTypeParserRuleCall_0_0(), semanticObject.getLiteralt());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralvLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns ConstDecl
	 *     Declaration returns ConstDecl
	 *     ConstDecl returns ConstDecl
	 *
	 * Constraint:
	 *     (constspec=ConstSpec | constspec2+=ConstSpec+)?
	 */
	protected void sequence_ConstDecl(ISerializationContext context, ConstDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns InterfaceType
	 *
	 * Constraint:
	 *     (methodspec+=MethodSpec* expressionlist=ExpressionList)
	 */
	protected void sequence_ConstSpec_InterfaceType(ISerializationContext context, InterfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns MapType
	 *
	 * Constraint:
	 *     (keytype=KeyType elemtype=ElementType expressionlist=ExpressionList)
	 */
	protected void sequence_ConstSpec_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.MAP_TYPE__KEYTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.MAP_TYPE__KEYTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.MAP_TYPE__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.MAP_TYPE__ELEMTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getKeytypeKeyTypeParserRuleCall_2_0(), semanticObject.getKeytype());
		feeder.accept(grammarAccess.getMapTypeAccess().getElemtypeElementTypeParserRuleCall_4_0(), semanticObject.getElemtype());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns Parameters
	 *
	 * Constraint:
	 *     (parameterlist=ParameterList? result=Result? expressionlist=ExpressionList)
	 */
	protected void sequence_ConstSpec_Parameters_Signature(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns PointerType
	 *
	 * Constraint:
	 *     (basetype=BaseType expressionlist=ExpressionList)
	 */
	protected void sequence_ConstSpec_PointerType(ISerializationContext context, PointerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.POINTER_TYPE__BASETYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.POINTER_TYPE__BASETYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointerTypeAccess().getBasetypeBaseTypeParserRuleCall_1_0(), semanticObject.getBasetype());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns SliceType
	 *
	 * Constraint:
	 *     (elemtype=ElementType expressionlist=ExpressionList)
	 */
	protected void sequence_ConstSpec_SliceType(ISerializationContext context, SliceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SLICE_TYPE__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SLICE_TYPE__ELEMTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSliceTypeAccess().getElemtypeElementTypeParserRuleCall_2_0(), semanticObject.getElemtype());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns StructType
	 *
	 * Constraint:
	 *     (fielddecl+=FieldDecl* expressionlist=ExpressionList)
	 */
	protected void sequence_ConstSpec_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstSpec returns Type
	 *
	 * Constraint:
	 *     expressionlist=ExpressionList
	 */
	protected void sequence_ConstSpec_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionlistExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Conversion returns Conversion
	 *
	 * Constraint:
	 *     (type=Type expression=Expression)
	 */
	protected void sequence_Conversion(ISerializationContext context, Conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns Conversion
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         expression=Expression 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         element=Element 
	 *         keyedelement+=KeyedElement*
	 *     )
	 */
	protected void sequence_Conversion_ElementList_Expression_KeyedElement_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns Conversion
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         expression=Expression 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         condition=Condition? 
	 *         poststmt=PostStmt
	 *     )
	 */
	protected void sequence_Conversion_Expression_ExpressionList_ForClause_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns Conversion
	 *     ShortVarDecl returns Conversion
	 *     InitStmt returns Conversion
	 *     PostStmt returns Conversion
	 *     ExpressionList returns Conversion
	 *
	 * Constraint:
	 *     (type=Type expression=Expression pr=PrimaryExpr2 exp=Expression2 expression2+=Expression*)
	 */
	protected void sequence_Conversion_Expression_ExpressionList_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecvStmt returns Conversion
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         expression=Expression 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         recvexpr=RecvExpr
	 *     )
	 */
	protected void sequence_Conversion_Expression_ExpressionList_PrimaryExpr_RecvStmt(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns Conversion
	 *     TypeSwitchStmt returns Conversion
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         expression=Expression 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         typesg=TypeSwitchGuard 
	 *         typecc+=TypeCaseClause*
	 *     )
	 */
	protected void sequence_Conversion_Expression_ExpressionList_PrimaryExpr_TypeSwitchStmt(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns Conversion
	 *
	 * Constraint:
	 *     (type=Type expression=Expression pr=PrimaryExpr2 exp=Expression2 element=Element)
	 */
	protected void sequence_Conversion_Expression_KeyedElement_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_1_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayLength returns Conversion
	 *     DeferStmt returns Conversion
	 *     ExpressionStmt returns Conversion
	 *     Channel returns Conversion
	 *     IncDecStmt returns Conversion
	 *     RecvExpr returns Conversion
	 *     Condition returns Conversion
	 *     Expression returns Conversion
	 *     Key returns Conversion
	 *     Element returns Conversion
	 *
	 * Constraint:
	 *     (type=Type expression=Expression pr=PrimaryExpr2 exp=Expression2)
	 */
	protected void sequence_Conversion_Expression_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_1_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeSwitchGuard returns Conversion
	 *     UnaryExpr returns Conversion
	 *     PrimaryExpr returns Conversion
	 *
	 * Constraint:
	 *     (type=Type expression=Expression pr=PrimaryExpr2)
	 */
	protected void sequence_Conversion_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_1_1_0(), semanticObject.getPr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2 exp=Expression2 element=Element keyedelement+=KeyedElement*)
	 */
	protected void sequence_ElementList_Expression_KeyedElement_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 element=Element keyedelement+=KeyedElement*)
	 */
	protected void sequence_ElementList_Expression_KeyedElement_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns Key
	 *
	 * Constraint:
	 *     (element=Element keyedelement+=KeyedElement*)
	 */
	protected void sequence_ElementList_Key_KeyedElement(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns KeyedElement
	 *
	 * Constraint:
	 *     (element=Element keyedelement+=KeyedElement*)
	 */
	protected void sequence_ElementList_KeyedElement(ISerializationContext context, KeyedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns LiteralValue
	 *
	 * Constraint:
	 *     (elementlist=ElementList? element=Element keyedelement+=KeyedElement*)
	 */
	protected void sequence_ElementList_KeyedElement_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprCaseClause returns ExprSwitchCase
	 *
	 * Constraint:
	 *     (expressionlist=ExpressionList? statementlist=StatementList)
	 */
	protected void sequence_ExprCaseClause_ExprSwitchCase(ISerializationContext context, ExprSwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprSwitchCase returns ExprSwitchCase
	 *
	 * Constraint:
	 *     expressionlist=ExpressionList?
	 */
	protected void sequence_ExprSwitchCase(ISerializationContext context, ExprSwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns ExprSwitchStmt
	 *     ExprSwitchStmt returns ExprSwitchStmt
	 *
	 * Constraint:
	 *     (simplestmt=SimpleStmt? expression=Expression? exprcase+=ExprCaseClause*)
	 */
	protected void sequence_ExprSwitchStmt(ISerializationContext context, ExprSwitchStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression2 returns Expression2
	 *
	 * Constraint:
	 *     (expression=Expression expression2=Expression2)?
	 */
	protected void sequence_Expression2(ISerializationContext context, Expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns Operand
	 *
	 * Constraint:
	 *     (
	 *         (literal=Literal | operandn=OperandName | expression=Expression) 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         condition=Condition? 
	 *         poststmt=PostStmt
	 *     )
	 */
	protected void sequence_Expression_ExpressionList_ForClause_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns ReceiverType
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         condition=Condition? 
	 *         poststmt=PostStmt
	 *     )
	 */
	protected void sequence_Expression_ExpressionList_ForClause_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns Operand
	 *     ShortVarDecl returns Operand
	 *     InitStmt returns Operand
	 *     PostStmt returns Operand
	 *     ExpressionList returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2 exp=Expression2 expression2+=Expression*)
	 */
	protected void sequence_Expression_ExpressionList_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecvStmt returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2 exp=Expression2 expression2+=Expression* recvexpr=RecvExpr)
	 */
	protected void sequence_Expression_ExpressionList_Operand_PrimaryExpr_RecvStmt(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns Operand
	 *     TypeSwitchStmt returns Operand
	 *
	 * Constraint:
	 *     (
	 *         (literal=Literal | operandn=OperandName | expression=Expression) 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         typesg=TypeSwitchGuard 
	 *         typecc+=TypeCaseClause*
	 *     )
	 */
	protected void sequence_Expression_ExpressionList_Operand_PrimaryExpr_TypeSwitchStmt(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns ReceiverType
	 *     ShortVarDecl returns ReceiverType
	 *     InitStmt returns ReceiverType
	 *     PostStmt returns ReceiverType
	 *     ExpressionList returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 expression2+=Expression*)
	 */
	protected void sequence_Expression_ExpressionList_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecvStmt returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 expression2+=Expression* recvexpr=RecvExpr)
	 */
	protected void sequence_Expression_ExpressionList_PrimaryExpr_ReceiverType_RecvStmt(ISerializationContext context, ReceiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns ReceiverType
	 *     TypeSwitchStmt returns ReceiverType
	 *
	 * Constraint:
	 *     (
	 *         type=Type 
	 *         pr=PrimaryExpr2 
	 *         exp=Expression2 
	 *         expression2+=Expression* 
	 *         typesg=TypeSwitchGuard 
	 *         typecc+=TypeCaseClause*
	 *     )
	 */
	protected void sequence_Expression_ExpressionList_PrimaryExpr_ReceiverType_TypeSwitchStmt(ISerializationContext context, ReceiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2 exp=Expression2 element=Element)
	 */
	protected void sequence_Expression_KeyedElement_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2 element=Element)
	 */
	protected void sequence_Expression_KeyedElement_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_2_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayLength returns Operand
	 *     DeferStmt returns Operand
	 *     ExpressionStmt returns Operand
	 *     Channel returns Operand
	 *     IncDecStmt returns Operand
	 *     RecvExpr returns Operand
	 *     Condition returns Operand
	 *     Expression returns Operand
	 *     Key returns Operand
	 *     Element returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2 exp=Expression2)
	 */
	protected void sequence_Expression_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayLength returns ReceiverType
	 *     DeferStmt returns ReceiverType
	 *     ExpressionStmt returns ReceiverType
	 *     Channel returns ReceiverType
	 *     IncDecStmt returns ReceiverType
	 *     RecvExpr returns ReceiverType
	 *     Condition returns ReceiverType
	 *     Expression returns ReceiverType
	 *     Key returns ReceiverType
	 *     Element returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2 exp=Expression2)
	 */
	protected void sequence_Expression_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_2_1_0(), semanticObject.getPr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpExpression2ParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldDecl returns FieldDecl
	 *
	 * Constraint:
	 *     (indentifierL=IdentifierList type=Type)?
	 */
	protected void sequence_FieldDecl(ISerializationContext context, FieldDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns ForClause
	 *
	 * Constraint:
	 *     (condition=Condition? poststmt=PostStmt)
	 */
	protected void sequence_ForClause(ISerializationContext context, ForClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns SendStmt
	 *
	 * Constraint:
	 *     (ch=Channel expression=Expression condition=Condition? poststmt=PostStmt)
	 */
	protected void sequence_ForClause_SendStmt(ISerializationContext context, SendStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns SimpleStmt
	 *
	 * Constraint:
	 *     (empty=EmptyStmt condition=Condition? poststmt=PostStmt)
	 */
	protected void sequence_ForClause_SimpleStmt(ISerializationContext context, SimpleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForStmt returns ForStmt
	 *
	 * Constraint:
	 *     ((condition+=Condition | for+=ForClause | range+=RangeClause)* block=Block)
	 */
	protected void sequence_ForStmt(ISerializationContext context, ForStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns FunctionDecl
	 *     FunctionDecl returns FunctionDecl
	 *
	 * Constraint:
	 *     (functionn=FunctionName signature+=Signature body+=FunctionBody?)
	 */
	protected void sequence_FunctionDecl(ISerializationContext context, FunctionDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Parameters
	 *     FunctionLit returns Parameters
	 *
	 * Constraint:
	 *     (parameterlist=ParameterList? result=Result? functionbody=FunctionBody)
	 */
	protected void sequence_FunctionLit_Parameters_Signature(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStmt returns IfStmt
	 *
	 * Constraint:
	 *     (simst=SimpleStmt? expression=Expression block=Block (ifs=IfStmt | block2=Block)?)
	 */
	protected void sequence_IfStmt(ISerializationContext context, IfStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDecl returns ImportDecl
	 *
	 * Constraint:
	 *     (imports+=ImportSpec | imports2+=ImportSpec+)?
	 */
	protected void sequence_ImportDecl(ISerializationContext context, ImportDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Index returns Index
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.INDEX__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.INDEX__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns InterfaceType
	 *     TypeLit returns InterfaceType
	 *     ElementType returns InterfaceType
	 *     BaseType returns InterfaceType
	 *     Result returns InterfaceType
	 *     InterfaceType returns InterfaceType
	 *     KeyType returns InterfaceType
	 *     TypeSpec returns InterfaceType
	 *     TypeDef returns InterfaceType
	 *     AliasDecl returns InterfaceType
	 *     TypeAssertion returns InterfaceType
	 *
	 * Constraint:
	 *     methodspec+=MethodSpec*
	 */
	protected void sequence_InterfaceType(ISerializationContext context, InterfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns InterfaceType
	 *
	 * Constraint:
	 *     (methodspec+=MethodSpec* expressionlist=ExpressionList?)
	 */
	protected void sequence_InterfaceType_VarSpec(ISerializationContext context, InterfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Key
	 *
	 * Constraint:
	 *     {Key}
	 */
	protected void sequence_Key(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns Key
	 *
	 * Constraint:
	 *     element=Element
	 */
	protected void sequence_Key_KeyedElement(ISerializationContext context, Key semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns KeyedElement
	 *
	 * Constraint:
	 *     element=Element
	 */
	protected void sequence_KeyedElement(ISerializationContext context, KeyedElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns LiteralValue
	 *
	 * Constraint:
	 *     (elementlist=ElementList? element=Element)
	 */
	protected void sequence_KeyedElement_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LabeledStmt returns LabeledStmt
	 *
	 * Constraint:
	 *     (label=Label statement=Statement)
	 */
	protected void sequence_LabeledStmt(ISerializationContext context, LabeledStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LABELED_STMT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LABELED_STMT__LABEL));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LABELED_STMT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LABELED_STMT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabeledStmtAccess().getLabelLabelParserRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getLabeledStmtAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LiteralType returns LiteralType
	 *
	 * Constraint:
	 *     (
	 *         structtype=StructType | 
	 *         arraytype=ArrayType | 
	 *         elementype=ElementType | 
	 *         slicetype=SliceType | 
	 *         maptype=MapType | 
	 *         typename=TypeName
	 *     )
	 */
	protected void sequence_LiteralType(ISerializationContext context, LiteralType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralValue returns LiteralValue
	 *     Key returns LiteralValue
	 *     Element returns LiteralValue
	 *
	 * Constraint:
	 *     elementlist=ElementList?
	 */
	protected void sequence_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     {Literal}
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns MapType
	 *     TypeLit returns MapType
	 *     ElementType returns MapType
	 *     BaseType returns MapType
	 *     Result returns MapType
	 *     MapType returns MapType
	 *     KeyType returns MapType
	 *     TypeSpec returns MapType
	 *     TypeDef returns MapType
	 *     AliasDecl returns MapType
	 *     TypeAssertion returns MapType
	 *
	 * Constraint:
	 *     (keytype=KeyType elemtype=ElementType)
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.MAP_TYPE__KEYTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.MAP_TYPE__KEYTYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.MAP_TYPE__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.MAP_TYPE__ELEMTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getKeytypeKeyTypeParserRuleCall_2_0(), semanticObject.getKeytype());
		feeder.accept(grammarAccess.getMapTypeAccess().getElemtypeElementTypeParserRuleCall_4_0(), semanticObject.getElemtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns MapType
	 *
	 * Constraint:
	 *     (keytype=KeyType elemtype=ElementType expressionlist=ExpressionList?)
	 */
	protected void sequence_MapType_VarSpec(ISerializationContext context, MapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns MethodDecl
	 *     MethodDecl returns MethodDecl
	 *
	 * Constraint:
	 *     (receiver=Receiver method=MethodName signature+=Signature body+=FunctionBody?)
	 */
	protected void sequence_MethodDecl(ISerializationContext context, MethodDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodSpec returns MethodSpec
	 *
	 * Constraint:
	 *     {MethodSpec}
	 */
	protected void sequence_MethodSpec(ISerializationContext context, MethodSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     greetings+=Compilation_initial
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Operand
	 *
	 * Constraint:
	 *     (literal=Literal | operandn=OperandName | expression=Expression)
	 */
	protected void sequence_Operand(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSwitchGuard returns Operand
	 *     UnaryExpr returns Operand
	 *     PrimaryExpr returns Operand
	 *
	 * Constraint:
	 *     ((literal=Literal | operandn=OperandName | expression=Expression) pr=PrimaryExpr2)
	 */
	protected void sequence_Operand_PrimaryExpr(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDecl returns ParameterDecl
	 *
	 * Constraint:
	 *     (indentifierL=IdentifierList? type=Type)
	 */
	protected void sequence_ParameterDecl(ISerializationContext context, ParameterDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterDecl
	 *
	 * Constraint:
	 *     (indentifierL=IdentifierList? type=Type parameterdecl+=ParameterDecl*)
	 */
	protected void sequence_ParameterDecl_ParameterList(ISerializationContext context, ParameterDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Receiver returns Parameters
	 *     Parameters returns Parameters
	 *
	 * Constraint:
	 *     parameterlist=ParameterList?
	 */
	protected void sequence_Parameters(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Parameters
	 *     TypeLit returns Parameters
	 *     ElementType returns Parameters
	 *     BaseType returns Parameters
	 *     FunctionType returns Parameters
	 *     Signature returns Parameters
	 *     Result returns Parameters
	 *     MethodSpec returns Parameters
	 *     KeyType returns Parameters
	 *     TypeSpec returns Parameters
	 *     TypeDef returns Parameters
	 *     AliasDecl returns Parameters
	 *     TypeAssertion returns Parameters
	 *
	 * Constraint:
	 *     (parameterlist=ParameterList? result=Result?)
	 */
	protected void sequence_Parameters_Signature(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns Parameters
	 *
	 * Constraint:
	 *     (parameterlist=ParameterList? result=Result? expressionlist=ExpressionList?)
	 */
	protected void sequence_Parameters_Signature_VarSpec(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns PointerType
	 *     TypeLit returns PointerType
	 *     ElementType returns PointerType
	 *     PointerType returns PointerType
	 *     BaseType returns PointerType
	 *     Result returns PointerType
	 *     KeyType returns PointerType
	 *     TypeSpec returns PointerType
	 *     TypeDef returns PointerType
	 *     AliasDecl returns PointerType
	 *     TypeAssertion returns PointerType
	 *
	 * Constraint:
	 *     basetype=BaseType
	 */
	protected void sequence_PointerType(ISerializationContext context, PointerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.POINTER_TYPE__BASETYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.POINTER_TYPE__BASETYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointerTypeAccess().getBasetypeBaseTypeParserRuleCall_1_0(), semanticObject.getBasetype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns PointerType
	 *
	 * Constraint:
	 *     (basetype=BaseType expressionlist=ExpressionList?)
	 */
	protected void sequence_PointerType_VarSpec(ISerializationContext context, PointerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr2 returns PrimaryExpr2
	 *
	 * Constraint:
	 *     (
	 *         pr=PrimaryExpr2 | 
	 *         (index=Index pr=PrimaryExpr2) | 
	 *         (slice=Slice pr=PrimaryExpr2) | 
	 *         (typeass=TypeAssertion pr=PrimaryExpr2) | 
	 *         (arguments=Arguments pr=PrimaryExpr2)
	 *     )?
	 */
	protected void sequence_PrimaryExpr2(ISerializationContext context, PrimaryExpr2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSwitchGuard returns ReceiverType
	 *     UnaryExpr returns ReceiverType
	 *     PrimaryExpr returns ReceiverType
	 *
	 * Constraint:
	 *     (type=Type pr=PrimaryExpr2)
	 */
	protected void sequence_PrimaryExpr_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrPrimaryExpr2ParserRuleCall_2_1_0(), semanticObject.getPr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RangeClause returns RangeClause
	 *
	 * Constraint:
	 *     (expressionlist=ExpressionList? expression=Expression)
	 */
	protected void sequence_RangeClause(ISerializationContext context, RangeClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodExpr returns ReceiverType
	 *     ReceiverType returns ReceiverType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_ReceiverType(ISerializationContext context, ReceiverType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RecvStmt returns RecvStmt
	 *
	 * Constraint:
	 *     recvexpr=RecvExpr
	 */
	protected void sequence_RecvStmt(ISerializationContext context, RecvStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECV_STMT__RECVEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECV_STMT__RECVEXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecvStmtAccess().getRecvexprRecvExprParserRuleCall_1_0(), semanticObject.getRecvexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStmt
	 *     ReturnStmt returns ReturnStmt
	 *
	 * Constraint:
	 *     expressionlist=ExpressionList?
	 */
	protected void sequence_ReturnStmt(ISerializationContext context, ReturnStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectStmt returns SelectStmt
	 *
	 * Constraint:
	 *     commclause+=CommClause*
	 */
	protected void sequence_SelectStmt(ISerializationContext context, SelectStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns SendStmt
	 *     SendStmt returns SendStmt
	 *     InitStmt returns SendStmt
	 *     PostStmt returns SendStmt
	 *
	 * Constraint:
	 *     (ch=Channel expression=Expression)
	 */
	protected void sequence_SendStmt(ISerializationContext context, SendStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SEND_STMT__CH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SEND_STMT__CH));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SEND_STMT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SEND_STMT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSendStmtAccess().getChChannelParserRuleCall_0_0(), semanticObject.getCh());
		feeder.accept(grammarAccess.getSendStmtAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns SendStmt
	 *     TypeSwitchStmt returns SendStmt
	 *
	 * Constraint:
	 *     (ch=Channel expression=Expression typesg=TypeSwitchGuard typecc+=TypeCaseClause*)
	 */
	protected void sequence_SendStmt_TypeSwitchStmt(ISerializationContext context, SendStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns SimpleStmt
	 *     InitStmt returns SimpleStmt
	 *     PostStmt returns SimpleStmt
	 *
	 * Constraint:
	 *     empty=EmptyStmt
	 */
	protected void sequence_SimpleStmt(ISerializationContext context, SimpleStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SIMPLE_STMT__EMPTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SIMPLE_STMT__EMPTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStmtAccess().getEmptyEmptyStmtParserRuleCall_0_1_0(), semanticObject.getEmpty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns SimpleStmt
	 *     TypeSwitchStmt returns SimpleStmt
	 *
	 * Constraint:
	 *     (empty=EmptyStmt typesg=TypeSwitchGuard typecc+=TypeCaseClause*)
	 */
	protected void sequence_SimpleStmt_TypeSwitchStmt(ISerializationContext context, SimpleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SliceType
	 *     TypeLit returns SliceType
	 *     ElementType returns SliceType
	 *     SliceType returns SliceType
	 *     BaseType returns SliceType
	 *     Result returns SliceType
	 *     KeyType returns SliceType
	 *     TypeSpec returns SliceType
	 *     TypeDef returns SliceType
	 *     AliasDecl returns SliceType
	 *     TypeAssertion returns SliceType
	 *
	 * Constraint:
	 *     elemtype=ElementType
	 */
	protected void sequence_SliceType(ISerializationContext context, SliceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SLICE_TYPE__ELEMTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SLICE_TYPE__ELEMTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSliceTypeAccess().getElemtypeElementTypeParserRuleCall_2_0(), semanticObject.getElemtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns SliceType
	 *
	 * Constraint:
	 *     (elemtype=ElementType expressionlist=ExpressionList?)
	 */
	protected void sequence_SliceType_VarSpec(ISerializationContext context, SliceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slice returns Slice
	 *
	 * Constraint:
	 *     ((expression=Expression? expression2=Expression?) | (expression3=Expression? expression4=Expression expression5=Expression))
	 */
	protected void sequence_Slice(ISerializationContext context, Slice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns StatementList
	 *     StatementList returns StatementList
	 *     FunctionBody returns StatementList
	 *
	 * Constraint:
	 *     statment+=Statement*
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         declaration=Declaration | 
	 *         labest=LabeledStmt | 
	 *         simplest=SimpleStmt | 
	 *         gotst=GoStmt | 
	 *         breakst=BreakStmt | 
	 *         continuest=ContinueStmt | 
	 *         gotost=GotoStmt | 
	 *         falltst=FallthroughStmt | 
	 *         block1=Block | 
	 *         if=IfStmt | 
	 *         switch=SwitchStmt | 
	 *         selectst=SelectStmt | 
	 *         forst=ForStmt | 
	 *         deferst=DeferStmt
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns StructType
	 *     TypeLit returns StructType
	 *     ElementType returns StructType
	 *     StructType returns StructType
	 *     BaseType returns StructType
	 *     Result returns StructType
	 *     KeyType returns StructType
	 *     TypeSpec returns StructType
	 *     TypeDef returns StructType
	 *     AliasDecl returns StructType
	 *     TypeAssertion returns StructType
	 *
	 * Constraint:
	 *     fielddecl+=FieldDecl*
	 */
	protected void sequence_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns StructType
	 *
	 * Constraint:
	 *     (fielddecl+=FieldDecl* expressionlist=ExpressionList?)
	 */
	protected void sequence_StructType_VarSpec(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCaseClause returns TypeSwitchCase
	 *
	 * Constraint:
	 *     (typelist=TypeList? statementlist=StatementList)
	 */
	protected void sequence_TypeCaseClause_TypeSwitchCase(ISerializationContext context, TypeSwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns TypeDecl
	 *     Declaration returns TypeDecl
	 *     TypeDecl returns TypeDecl
	 *
	 * Constraint:
	 *     (typespec=TypeSpec | typespec2+=TypeSpec+)?
	 */
	protected void sequence_TypeDecl(ISerializationContext context, TypeDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeList returns TypeList
	 *
	 * Constraint:
	 *     (type=Type type2+=Type*)
	 */
	protected void sequence_TypeList(ISerializationContext context, TypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSwitchCase returns TypeSwitchCase
	 *
	 * Constraint:
	 *     typelist=TypeList?
	 */
	protected void sequence_TypeSwitchCase(ISerializationContext context, TypeSwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns TypeSwitchStmt
	 *     TypeSwitchStmt returns TypeSwitchStmt
	 *
	 * Constraint:
	 *     (typesg=TypeSwitchGuard typecc+=TypeCaseClause*)
	 */
	protected void sequence_TypeSwitchStmt(ISerializationContext context, TypeSwitchStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     ElementType returns Type
	 *     BaseType returns Type
	 *     Result returns Type
	 *     KeyType returns Type
	 *     TypeSpec returns Type
	 *     TypeDef returns Type
	 *     AliasDecl returns Type
	 *     TypeAssertion returns Type
	 *
	 * Constraint:
	 *     {Type}
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns Type
	 *
	 * Constraint:
	 *     expressionlist=ExpressionList?
	 */
	protected void sequence_Type_VarSpec(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns VarDecl
	 *     Declaration returns VarDecl
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (varspec=VarSpec | varspec2+=VarSpec+)?
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
