/**
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import java.util.LinkedHashMap;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.xtext.example.mydsl.go.BasicLit;
import org.xtext.example.mydsl.go.ConstDecl;
import org.xtext.example.mydsl.go.ElementType;
import org.xtext.example.mydsl.go.Expression;
import org.xtext.example.mydsl.go.Expression2;
import org.xtext.example.mydsl.go.ForStmt;
import org.xtext.example.mydsl.validation.AbstractGoValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class GoValidator extends AbstractGoValidator {
  private final LinkedHashMap<Object, Object> ids = CollectionLiterals.<Object, Object>newLinkedHashMap();
  
  public static void main(final String[] args) {
    InputOutput.<String>println("Hello World");
  }
  
  @Check
  public void checkFor(final ForStmt fors) {
    ElementType _elemtype = fors.getCondition().getExp().getElemtype();
    boolean _notEquals = (!Objects.equal(_elemtype, boolean.class));
    if (_notEquals) {
      this.error("Semantic Error: for condition must be boolean", null);
    }
  }
  
  @Check
  public void checkExpression(final Expression e) {
    if (((e.getExp() != null) && (e.getExp() instanceof Expression2))) {
      String binaryOperator = e.getExp().getBop();
      if ((Objects.equal(binaryOperator, "||") || Objects.equal(e.getExp().getBop(), "&&"))) {
      }
      boolean _isArithimeticOp = this.isArithimeticOp(binaryOperator);
      if (_isArithimeticOp) {
        BasicLit basicLiteral1 = e.getUp().getPr().getOp().getLiteral().getBasic();
        BasicLit basicLiteral2 = e.getExp().getExpression().getUp().getPr().getOp().getLiteral().getBasic();
        this.checkAritimeticLits(basicLiteral1, basicLiteral2, binaryOperator);
      }
    }
  }
  
  @Check
  public void checkConstDecl(final ConstDecl cd) {
    String constId = cd.getConstspec().getId().getId();
    String constType = cd.getConstspec().getTp().getTp();
    BasicLit constExp = cd.getConstspec().getExpressionlist().getExp().getUp().getPr().getOp().getLiteral().getBasic();
    if (((constType != null) && (constExp != null))) {
      this.checkAndMakeConstDecl(constId, constType, constExp);
    }
  }
  
  /**
   * Checa se dois literais são compativeis em uma operação aritimética
   */
  public void checkAritimeticLits(final BasicLit basicLit1, final BasicLit basicLit2, final String binaryOp) {
    if (((basicLit1 != null) && (basicLit2 != null))) {
      if (((basicLit1.getStrd() != null) || (basicLit2.getStrd() != null))) {
        if (((basicLit1.getStrd() != null) && Objects.equal(binaryOp, "+"))) {
          String _strd = basicLit2.getStrd();
          boolean _tripleEquals = (_strd == null);
          if (_tripleEquals) {
            this.error("Semantic Error: Invalid arithmetic operation", null);
          }
        } else {
          if (((basicLit2.getStrd() != null) && Objects.equal(binaryOp, "+"))) {
            String _strd_1 = basicLit1.getStrd();
            boolean _tripleEquals_1 = (_strd_1 == null);
            if (_tripleEquals_1) {
              this.error("Semantic Error: Invalid arithmetic operation", null);
            }
          } else {
            this.error(
              (("Semantic Error: Invalid arithmetic operation, operator " + binaryOp) + " not defined on string."), null);
          }
        }
      } else {
        if ((((basicLit1.getIntd() == null) && (basicLit1.getFloatd() == null)) && (basicLit1.getImagd() == null))) {
          this.error("Semantic Error: Invalid arithmetic operation", null);
        }
      }
    }
  }
  
  /**
   * Checa se a declaração de uma constante é valida
   */
  public void checkAndMakeConstDecl(final String id, final String constType, final BasicLit literal) {
    boolean error = false;
    boolean _equals = Objects.equal(constType, "float");
    if (_equals) {
      String _intd = literal.getIntd();
      boolean _tripleNotEquals = (_intd != null);
      if (_tripleNotEquals) {
        String _intd_1 = literal.getIntd();
        Double _double = new Double(_intd_1);
        this.ids.put(id, _double);
      } else {
        String _floatd = literal.getFloatd();
        boolean _tripleNotEquals_1 = (_floatd != null);
        if (_tripleNotEquals_1) {
          String _floatd_1 = literal.getFloatd();
          Double _double_1 = new Double(_floatd_1);
          this.ids.put(id, _double_1);
        } else {
          error = true;
          this.error("Semantic Error: Invalid const declaration, operator \r\n\t\t\t\t\t\tnot assigned to float.", null);
        }
      }
    } else {
      boolean _equals_1 = Objects.equal(constType, "int");
      if (_equals_1) {
        String _intd_2 = literal.getIntd();
        boolean _tripleNotEquals_2 = (_intd_2 != null);
        if (_tripleNotEquals_2) {
          String _intd_3 = literal.getIntd();
          Integer _integer = new Integer(_intd_3);
          this.ids.put(id, _integer);
        } else {
          String _floatd_2 = literal.getFloatd();
          boolean _tripleNotEquals_3 = (_floatd_2 != null);
          if (_tripleNotEquals_3) {
            String _intd_4 = literal.getIntd();
            Integer _integer_1 = new Integer(_intd_4);
            this.ids.put(id, _integer_1);
          } else {
            error = true;
            this.error("Semantic Error: Invalid const declaration, operator \r\n\t\t\t\t\t\tnot assigned to int.", null);
          }
        }
      } else {
        boolean _equals_2 = Objects.equal(constType, "string");
        if (_equals_2) {
          String _strd = literal.getStrd();
          boolean _tripleNotEquals_4 = (_strd != null);
          if (_tripleNotEquals_4) {
            String _strd_1 = literal.getStrd();
            String _string = new String(_strd_1);
            this.ids.put(id, _string);
          } else {
            error = true;
            this.error("Semantic Error: Invalid const declaration, operator \r\n\t\t\t\t\t\tnot assigned to string.", null);
          }
        }
      }
    }
    if (((id != id.toUpperCase()) && (!error))) {
      this.warning("Constants usually be declared with Upper Case", null);
    }
  }
  
  protected boolean isArithimeticOp(final String binaryOperator) {
    return ((((Objects.equal(binaryOperator, "+") || Objects.equal(binaryOperator, "-")) || Objects.equal(binaryOperator, "*")) || Objects.equal(binaryOperator, "/")) || Objects.equal(binaryOperator, "%"));
  }
}
