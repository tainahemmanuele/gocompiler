/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.validation

import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.go.*
import org.xtext.example.mydsl.go.Expression
import org.xtext.example.mydsl.go.Expression2
import org.xtext.example.mydsl.go.IdentifierList
import org.xtext.example.mydsl.validation.util.Typer

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GoValidator extends AbstractGoValidator {
	
	val ids = newLinkedHashMap()
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GoPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	def static void main(String[] args) {
	 println("Hello World")
	}

	@Check
	def checkFor(ForStmt fors) {
		if(fors.condition.exp.elemtype != boolean) {
			error("Semantic Error: for condition must be boolean", null)
		}
	}
	
	@Check
	def checkExpression(Expression e) {
		
		if(e.exp !== null && e.exp instanceof Expression2) {
			
			var binaryOperator = e.exp.bop;
			
			if(binaryOperator == "||" || e.exp.bop == "&&") {
				//checkBooleanExp(e.exp.expression)
			}
			
			if(isArithimeticOp(binaryOperator)) {
				var basicLiteral1 = e.up.pr.op.literal.basic
				var basicLiteral2 = e.exp.expression.up.pr.op.literal.basic		
				checkAritimeticLits(basicLiteral1, basicLiteral2, binaryOperator)
			}
		}
	}
	
	@Check
	def checkVarSpec(VarSpec varspec) {
		var type = varspec.tp2.tp.toString.toLowerCase
		info("Tipo passado: " + type, null)
		print("Não nulo: ")
		println(type !== null)
		if (type !== null) {
			info ("Entrou no if", null)
			var typeExp = Typer.typeExp(varspec.expressionlist.exp)
			println("Tipo Exp: " + typeExp)
			println(typeExp !== type)
			println(Typer.typeLargerThan(type, typeExp))
			if (typeExp != type || Typer.typeLargerThan(type, typeExp)) {
				error("Semantic Error: Variable " + varspec.id.id + " and Expression type mismatching", null)
			}
			var explist = varspec.expressionlist.expression2
			var varlist = varspec.id.id2
			for (i : 0 ..< explist.size) {
				typeExp = Typer.typeExp(explist.get(i))
				if (typeExp != type  || Typer.typeLargerThan(type, typeExp)) {
					error("Semantic Error: Variable " + varlist.get(i) + " and Expression type mismatching", null)
				}
			}
			ids.put(varspec.id.id, type)
			for (id : varlist) {
				ids.put(id, type)
			}
			
		}
	}
	
	/*
	 * Checa se dois literais são compativeis em uma operação aritimética 
	 */
	def checkAritimeticLits(BasicLit basicLit1, BasicLit basicLit2, String binaryOp) {
		if(basicLit1 !== null && basicLit2 !== null) {
			if(basicLit1.strd !== null || basicLit2.strd !== null) {
				if(basicLit1.strd !== null && binaryOp == "+") {
					if(basicLit2.strd === null) {
						error("Semantic Error: Invalid arithmetic operation", null)
					}
				}
				else if(basicLit2.strd !== null && binaryOp == "+") {
					if(basicLit1.strd === null) {
						error("Semantic Error: Invalid arithmetic operation", null)
					}
				}else {
					error("Semantic Error: Invalid arithmetic operation, operator "
							+ binaryOp + " not defined on string.", null
						)
				}
			}else if(basicLit1.intd === null && basicLit1.floatd  === null && basicLit1.imagd === null) {
				error("Semantic Error: Invalid arithmetic operation" , null)
			}
		}
	}
	
	/*
	def checkBooleanExp(Expression expression) {
		
		if(expression.exp !== null) {
			checkBooleanExp(expression.exp.expression)
			
		} else if(expression.elemtype != boolean && expression.elemtype !== null) {
			error("Semantic Error: Invalid argument type" + expression.elemtype, null)
		}
		
	} */


	protected def boolean isArithimeticOp(String binaryOperator) {
		return (binaryOperator == "+" || binaryOperator == "-" || binaryOperator == "*"
			|| binaryOperator == "/" || binaryOperator == "%")
	}
	
	
	
}
