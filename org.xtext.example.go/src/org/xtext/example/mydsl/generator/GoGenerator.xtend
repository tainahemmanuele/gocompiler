/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.go.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GoGenerator extends AbstractGenerator {

	Integer regCount = 0
	Integer lineCount = 0

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (f : resource.allContents.toIterable.filter(FunctionDecl))
			fsa.generateFile(f.functionn.toString + '.txt', f.genFunc)
	}
	
	def genFunc(FunctionDecl f) '''
		<<lineCount>>: LD SP 1000
		<<nextLine>>
		<<f.body.genFunctionBody>>
	'''
	
	def genFunctionBody(FunctionBody fb) '''
		<<fb.block.genBlock>>
	'''
	
	def genBlock(Block b) '''
		<<IF b.statementlist != null>>
			<<b.statementlist.genStatementList>>
		<<ENDIF>>
	'''
	
	def genStatementList(StatementList sl) '''
		<<FOR stmt : sl.statements>>
			<<stmt.genStatement>>
		<<ENDFOR>>
	'''
	
	def genStatement(Statement s) '''
		<<IF s.declaration != null>>
			<<genDeclaration(s.declaration)>>
		<<ELSEIF s.simplest != null>>
			<<genSimpleStmt(s.simplest)>>
		<<ELSEIF s.forst != null>>
			<<genForStmt(s.forst)>>
		<<ENDIF>>
	'''
	
	def genDeclaration(Declaration d)'''
		<<IF d.constdecl != null>>
			<<genConstDecl(d.constdecl)>>
		<<ELSEIF d.vardecl != null>>
			<<genVarDecl(d.vardecl)>>
		<<ENDIF>>
	'''
	
	def genSimpleStatement(SimpleStmt ss)'''
		<<IF ss.inc != null>>
			<<genIncDecStmt(ss.inc)>>
		<<ELSEIF ss.ass != null>>
			<<genAssignment(ss.ass)>>
		<<ELSEIF ss.svd != null>>
			<<genShortVarDecl(ss.svd)>>
		<<ELSEIF ss.es != null>>
			<<genExpressionStmt(ss.es)>>
		<ENDIF>>
	'''
	
	def genForStmt(ForStmt fs)'''
		#FOR
		<<IF fs.for != null>>
			<<genForClause(fs.for)>>
		<<ELSEIF fs.condition != null>>
			<<genCondition(f.condition)>>
		<<ENDIF>>
		<<IF fs.block != null>>
			<<genBlock(fs.block)>>
		<<ENDIF>>
		<<lineCount>>: BR #FOR
		<<nextLine>>
		#ENDFOR
	'''
	
	def genForClause(ForClause fc)'''
		<<IF fc.init != null>>
			<<genInitStmt(fc.init)>>
		<<ENDIF>>
		<<IF fc.condition != null>>
			<<genCondition(fc.condition)>>
		<<ENDIF>>
		<<IF fc.poststmt != null>>
			<<genPostStmt(fc.poststmt)>>
		<<ENDIF>>
	'''
	
	def genInitStmt(InitStmt is)'''
		<<IF is.simple != null>>
			<<genSimpleStmt(is.simple)>>
		<<ENDIF>>
	'''
	
	def genCondition(Condition c)'''
		<<IF c.exp != null>>
			<<genExpression(c.exp)>>
			<<IF c.exp.exp.bop.toString.equals("<")>>
				<<lineCount>>: BLTZ R<<regCount>>, #ENDFOR
				<<nextLine>>
			<<ELSEIF c.exp.exp.bop.toString.equals("<=")>>
				<<lineCount>>: BLEZ R<<regCount>>, #ENDFOR
				<<nextLine>>
			<<ELSEIF c.exp.exp.bop.toString.equals(">")>>
				<<lineCount>>: BGTZ R<<regCount>>, #ENDFOR
				<<nextLine>>
			<<ELSEIF c.exp.exp.bop.toString.equals("<=")>>
				<<lineCount>>: BGEZ R<<regCount>>, #ENDFOR
				<<nextLine>>
			<<ENDIF>>
		<<ENDIF>>
	'''
	
	def genPostStmt(PostStmt ps)'''
		<<IF ps.simple != null>>
			<<genSimpleStmt(ps.simple)>>
		<<ENDIF>>
	'''
	
	def genIncDecStmt(IncDecStmt inc)'''
		<<IF inc.exp != null >>
			<<genExpression(inc.exp)>>
		<<ENDIF>>
	'''
	
	def genAssignment(Assignment ass)'''
		<<IF ass.expressionlist != null>>
			<<genExpressionList(ass.expressionlist)>>
		<<ELSEIF ass.expressionlist2 != null>>
			<<genExpressionList(ass.expressionlist)>>
		<<ENDIF>>
	'''
	
	def genShortVarDecl(ShortVarDecl ss)'''
		<<IF ss.idl != null>>
			<<genIdentifierList(ss.idl)>>
		<<ELSEIF ss.epl != null>>
			<<genExpressionList(ss.epl)>>
		<<ENDIF>>
	'''
	
	def genExpressionStmt(ExpressionStmt es)'''
		<<IF es.exp != null>>
			<<genExpression(es.exp)>>
		<<ENDIF>>	
	'''
	def genExpression(Expression exp)'''
		<<IF exp.up != null >>
			<<IF exp.up.pr.op.literal != null>>
				<<IF exp.exp ==null >>
					<<IF exp.up.pr.op.literal.basic.strd != null>>
						<<genStringExpression(exp)>>
					<<ENDIF>>
				<<ELSE>>
					<<IF exp.exp.bop.equals("+")  >>
						<<genIntLiteralExpression(exp)>>
					<<ELSE IF exp.exp.bop.equals("-")  >>
						<<genIntLiteralExpression(exp)>>
					<<ELSE IF exp.exp.bop.equals("*")  >>
						<<genIntLiteralExpression(exp)>>
					<<ELSE IF exp.exp.bop.equals("/")  >>
						<<genIntLiteralExpression(exp)>>
					<<ELSE>>
						<<genLogicalExpression(exp)>>
					<<ENDIF>>
				<<ENDIF>>
				
			<<ENDIF>>
		<<ENDIF>>
	'''
	
	def genStringExpression(Expression exp) '''
		«lineCount.toString()»: LD R«regCount.toString()», "«exp.up.pr.op.literal.basic.strd»"
		«nextReg»
		«nextLine»
	'''
	
	def genIntLiteralExpression(Expression exp)'''
		«lineCount.toString()»: LD R«regCount.toString()», #«exp.up.pr.op.literal.basic.intd»
		«nextReg»
		«nextLine»
		«lineCount.toString()»: LD R«regCount.toString()», #«exp.exp.expression.up.pr.op.literal.basic.intd»
		«nextReg»
		«nextLine»
		«IF exp.exp.bop.equals("+")»
			«lineCount.toString()»: ADD R«new Integer(regCount-2).toString()», R«new Integer(regCount-1).toString()» , R«new Integer(regCount-2).toString()»
			«nextLine»
		«ELSEIF exp.exp.bop.equals("*")»
			«lineCount.toString()»: MUL R«new Integer(regCount-2).toString()», R«new Integer(regCount-1).toString()» , R«new Integer(regCount-2).toString()»
			«nextLine»
		«ELSEIF exp.exp.bop.equals("/")»
			«lineCount.toString()»: DIV R«new Integer(regCount-2).toString()», R«new Integer(regCount-1).toString()» , R«new Integer(regCount-2).toString()»
			«nextLine»
		«ELSEIF exp.exp.bop.equals("-")»
			«lineCount.toString()»: SUB R«new Integer(regCount-2).toString()», R«new Integer(regCount-1).toString()» , R«new Integer(regCount-2).toString()»
			«nextLine»
		«ENDIF»
		«nextReg»
	'''
	
	def genLogicalExpression(Expression exp)'''
		«lineCount.toString()»: LD R«regCount.toString()», #«exp.up.pr.op.literal.basic.intd»
		«nextReg»
		«nextLine»
		«lineCount.toString()»: LD R«regCount.toString()», #«exp.exp.expression.up.pr.op.literal.basic.intd»
		«nextReg»
		«nextLine»
		«IF exp.exp.bop.toString.equals("<")»
			«lineCount.toString()»: SUB R«new Integer(regCount).toString()», R«new Integer(regCount-2).toString()» , R«new Integer(regCount-1).toString()»
			«nextLine»
			«lineCount.toString()»: BGTZ R«new Integer(regCount).toString()», #ENDFOR
			«nextLine»
		«ELSEIF  exp.exp.bop.toString.equals(">")»
			«lineCount.toString()»: SUB R«new Integer(regCount).toString()», R«new Integer(regCount-2).toString()» , R«new Integer(regCount-1).toString()»
			«nextLine»
			«lineCount.toString()»: BGTZ R«new Integer(regCount).toString()», #ENDFOR
			«nextLine»
		«ELSEIF  exp.exp.bop.toString.equals(">=")»
			«lineCount.toString()»: SUB R«new Integer(regCount).toString()», R«new Integer(regCount-2).toString()» , R«new Integer(regCount-1).toString()»
			«nextLine»
			«lineCount.toString()»: BGEZ R«new Integer(regCount).toString()», #ENDFOR
			«nextLine»
		«ELSEIF  exp.exp.bop.toString.equals("<=")»
			«lineCount.toString()»: SUB R«new Integer(regCount).toString()», R«new Integer(regCount-2).toString()» , R«new Integer(regCount-1).toString()»
			«nextLine»
			«lineCount.toString()»: BGEZ R«new Integer(regCount).toString()», #ENDFOR
			«nextLine»	
		«ELSEIF  exp.exp.bop.toString.equals("==")»
			«lineCount.toString()»: SUB R«new Integer(regCount).toString()», R«new Integer(regCount-2).toString()» , R«new Integer(regCount-1).toString()»
			«nextLine»
			«nextReg»
			«lineCount.toString()»: BGEZ R«new Integer(regCount).toString()», #ENDFOR
			«nextLine»
		«ELSEIF  exp.exp.bop.toString.equals("!=")»
			«lineCount.toString()»: SUB R«new Integer(regCount).toString()», R«new Integer(regCount-2).toString()» , R«new Integer(regCount-1).toString()»
			«nextLine»
			«nextReg»
			«lineCount.toString()»: BGEZ R«new Integer(regCount).toString()», #ENDFOR
			«nextLine»
		«ENDIF»
	'''
	
	def void nextReg() {
		regCount++
	}
	
	def void nextLine() {
		lineCount = lineCount + 8
	}
	
	
}
